JavaScript高级(注意点)
----------------------------     yaoyikun      ----------------------------------------


关键字的作用
//_________________________________________________________________________________-
in关键字
//in的三个作用:(针对数组和对象)
    //1.for in 进行数组及对象遍历
    //2.语法:  "属性名/方法名" in 对象      对象中是否含有此属性及方法   返回值为布尔类型
    //3.语法:  数字   in   数组名          判断一个数组中是否含有"数字"的下标 
         //补充:  数组.indexOf(元素)       判断数组中是否含有某个元素,用indexOf方法,如果有返回值为下标,没有返回值为-1

delete关键字
//delete的两个作用:
    //语法:  delete 变量名              可以删除没有用var声明的变量(全局变量)
    //语法:  delete  对象名.成员名      可以动态删除对象成员(属性/方法)


面向对象的应用
//____________________________________________________________________________________-
面向对象编程
//面向对象和面向过程一样,都是一种解决问题的思路
//面向对象:注重结果    其实就是面向过程的一种封装
//面向过程:注重过程

//对象的理解
    //对象和数组,变量一样,都是用来存放数据的  对象用属性及方法进行存储
    //抽象化/具体化   对象是一个具体的存在


面向对象语言三大特性:封装,继承,多态
//js没有多态,js不是面向对象语言,是一种基于对象的语言   js中没有多态
//封装:就是将功能封装整合对象内,只对外界暴露接口API 使用时,只需考虑接口用法,而不需考虑具体实现
//继承:js中继承是对象之间的继承,如果对象A想拥有对象B的成员,那就可以让对象A继承对象B 


继承
//方法:
//混入式:遍历赋值,就是给A对象添加成员  
//遍历B  赋值   对象A[key]=对象B[key]
for(var key in wangjianlin){
    wangsicong[key] = wangjianlin[key];//实际上是给wangsicong这个对象添加成员
}

//替换原型式:
// 对象A.prototype=对象B

//混合式:
// 遍历B  赋值  对象A.prototype[key]=对象B[key];  //给A对象原型添加成员



原型链
//____________________________________________________________________________
原型prototype
//原型:构造函数被创建时,系统会自动为我们创建一个与之对应的对象
//作用:就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作         从原型对象衍生出来的子对象
//语法:   构造函数.prototype
//原型的特性:对象添加属性及方法(一般为实例化出来函数共有的属性及方法   共有的数据才可以向原型中添加)
    //访问原型中成员:
        //原型自己可以访问
        //原型对应的构造函数实例化出来的对象
    //原型访问成员(方法/属性)原则:
        //如果对象自己有这个成员,那就访问自己的
        //如果对象自己没有这个成员,才去访问原型的
        //访问原型(往原型中添加数据,修改原型中数据)一定遵守  构造函数.prototype格式
//原型替换:
    //实例化对象访问原型中的成员,是访问修改之前还是修改之后:取决于实例化对象是修改原型之前出来,还是修改之后出来

实例化对象.__proto__
//属于对象的属性,指向创建的对象的构造函数的原型
    //使用注意:.__proto__不是标准的w3c属性,是ie的,虽然现在浏览器都支持它,但是开发中不要用它去访问原型


原型.constructor
//是属于原型对象的属性,指向原型的构造函数
// prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。
//constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的
    //使用注意:当原型发生替换时,constructor指向会丢失,可以使用原型的属性方法重新指向  constructor:构造函数

原型链
//概念:每一个对象都有原型,原型又是对象,所以原型又有原型,那就形成了链式结构,成为原型链
//作用:对象访问成员的访问规则

内置对象的原型链
//数组对象的原型链
    //实例化arr对象.__proto__  == Array.prototype
    //实例化arr对象.__proto__.__proto__  == Object.prototype
    //注意点:实例化对象arr调用toString()得到结果格式和实例化obj对象调用的toString()方法得到的不是一样的,分别调用各自原型的方法
//Date对象的原型链
    //实例化date对象.__proto__  == Date.prototype
    //实例化date对象.__proto__.__proto__   ==  Object.prototype
//Function对象
    //实例化test对象.__proto__  ==  Function.prototype
    //实例化test对象.__proto__.__proto__  == Object.prototype
//构造函数对象
    //例  Function Student(){}
    //构造函数Student.__proto__ ==  Function.prototype
    //构造函数Student.__proto__.__proto__ == Object.prototype

普通函数及构造函数
//普通函数和构造函数都是函数
//都可以直接调用  直接调用那函数中的this就是window
//都可以配合new关键字调用  ,new关键字配合调用那函数中的this就是new关键字创建出来的对象
//构造函数的名首字母一般大写



js高级方法
//__________________________________________________________________________-___________
闭包
//概念:就是声明在一个函数内部,可以访问函数内部的局部变量的这么一个函数
//定义在一个函数内部的函数，静态保存所有了父级作用域的内部函数
function test(){
    var num=10;
    function test2(){
        console.log(num);
    }
    return test2;
}
// 调用test函数会得到一个返回值,返回值是test2这个函数本身,所以这里的fn就相当于test2本身
var fn=test();
// 调用fn  相当于调用test2
fn()

闭包的作用
//01:提升变量的生命周期(变量的生命周期:从声明到回收)
    //局部变量:从声明这个局部变量开始,到声明他的函数执行完毕结束
    //全局变量:从声明到程序结束被回收
//02.声明在函数内部的局部变量,在函数外面不能访问  可以使用闭包访问
//03.提供有限的访问权限
function test1() {
    var num = 10;
    function getNum() {
        return num;
    }
    function setNum(value) {
        //这里是一个函数,那就可以写任意代码,那就可以写限制赋值代码
        if (value > 1 && value <= 140) {
            num = value;
        }
    }
    return {
        getNum: getNum,
        setNum: setNum
    };
}
var obj = test1(); //调用test1函数会得到一个对象,这个对象里面有2个函数,一个getNum,一个setNum
obj.setNum(100);
//调用test函数会的到对象,对象里封装的两个函数


闭包的使用注意
//使用的局部变量每次都是同一个,那外部这个函数就只需调用一次  
//使用的局部变量每次都不是同一个,那外部变量函数就调用多次       




var res = (function(num){ return num == 1?1:num * arguments.callee(num-1) })(5)